#!/usr/bin/env python3

"""
Check page 160 onwards for details of the following:
https://edge.edx.org/c4x/BITSPilani/EEE231/asset/8086_family_Users_Manual_1_.pdf
"""

import argparse
from os import PathLike
from typing import Optional

OP_ENCODING_8086: dict[str, str] = {
    "1101": "MOV",
    "100010": "MOV",
}


class Disassemble:
    def __init__(self, filepath: PathLike):
        self._file_path: PathLike = filepath
        self._machine_code: bytes

        self._op_code: str = ""
        self._d: Optional[str] = ""
        self._w: str = ""

        self._mod: str = ""
        self._reg: str = ""
        self._rm: str = ""

        self.src: str = ""
        self.dst: str = ""

        self._src_nmemonic: str = ""
        self._dst_nmemonic: str = ""

    def _read_machine_code(self):
        with open(self._file_path, "rb") as f:
            self._machine_code: bytes = f.read()

    def _get_op_code(self):
        self._op_binary: str = self._binary_code[:6]
        self._op_code: str = OP_ENCODING_8086.get(self._op_binary, "")
        if not self._op_code:
            self._op_binary: str = self._binary_code[:4]
            self._op_code: str = OP_ENCODING_8086.get(self._op_binary, "")

    def _get_d_and_w(self) -> tuple[Optional[str], str]:
        self._d: Optional[str] = None
        self._w: str = self._binary_code[-1]  # 8th bit

        if self._op_binary == "100010":
            self._d = self._binary_code[-2]  # 7th bit
        elif self._op_binary == "1101":
            self._d = None

        return self._d, self._w

    def _get_src_and_dst_mod(self, reg, rm):
        self._mod: str = self._binary_code[:2]

        if self._d == "1":
            self._src: str = reg
            self._dst: str = rm
        else:
            self._src: str = rm
            self._dst: str = reg

    def _get_mnemonics(self):
        nmemonic_map: dict[str, str] = {}
        if self._mod == "11":
            if self._w == "0":
                nmemonic_map: dict[str, str] = {
                    "000": "AL",
                    "001": "CL",
                    "010": "DL",
                    "011": "BL",
                    "100": "AH",
                    "101": "CH",
                    "110": "DH",
                    "111": "BH",
                }
            elif self._w == "1":
                nmemonic_map: dict[str, str] = {
                    "000": "AX",
                    "001": "CX",
                    "010": "DX",
                    "011": "BX",
                    "100": "SP",
                    "101": "BP",
                    "110": "SI",
                    "111": "DI",
                }
        elif self._mod == "00":
            nmemonic_map: dict[str, str] = {
                "000": "[BX + SI]",
                "001": "[BX + DI]",
                "010": "[BP + SI]",
                "011": "[BP + DI]",
                "100": "[SI]",
                "101": "[DI]",
                "110": "DIR]CT ADDRESS",
                "111": "[BX]",
            }
        elif self._mod == "01":
            nmemonic_map: dict[str, str] = {
                "000": "[BX + SI] + D8",
                "001": "[BX + DI] + D8",
                "010": "[BP + SI] + D8",
                "011": "[BP + DI] + D8",
                "100": "[SI] + D8",
                "101": "[DI] + D8",
                "110": "[BP] + D8",
                "111": "[BX] + D8",
            }
        elif self._mod == "10":
            nmemonic_map: dict[str, str] = {
                "000": "[BX + SI] + D16",
                "001": "[BX + DI] + D16",
                "010": "[BP + SI] + D16",
                "011": "[BP + DI] + D16",
                "100": "[SI] + D16",
                "101": "[DI] + D16",
                "110": "[BP] + D16",
                "111": "[BX] + D16",
            }

        if not nmemonic_map:
            print("Failed to find nmemonic_map...")
            return ""

        self._src_nmemonic: str = nmemonic_map.get(self._src, "")
        self._dst_nmemonic: str = nmemonic_map.get(self._dst, "")

    def run(self):
        self._read_machine_code()

        for i, each_byte in enumerate(self._machine_code):
            self._binary_code: str = format(each_byte, "08b")

            if i % 2 == 0:
                self._get_op_code()
                self._get_d_and_w()
                # print(f"OP: {self._op_code}, D: {self._d}, W: {self._w}")
            else:
                if not self._op_code:
                    print(f"No op code, previous byte okay?: {self._binary_code}")
                    return
                reg: str = self._binary_code[2:5]
                rm: str = self._binary_code[5:]

                self._get_src_and_dst_mod(reg, rm)
                self._get_mnemonics()

                # print(f"MOD: {self._mod}, REG: {reg}, RM: {rm}")

                print(
                    f"{self._op_code} {self._src_nmemonic}, {self._dst_nmemonic}".lower()
                )


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="Disassembler",
        description="Disassembles machine code to assembly language",
    )
    parser.add_argument("filepath")
    args = parser.parse_args()
    filepath: PathLike = args.filepath

    disassembler = Disassemble(filepath)

    disassembler.run()
